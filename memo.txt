1회차.

document.querySelector('h4').innerHTML = post;
>> 기존 자바스크립트에서 html에 변수 넣던 방법.

변수 넣을 땐 {} 중괄호.  

style 넣을 땐 style = { { 스타일명 : '값' } }


2회차.

return() 안에는 병렬로 태그 2개 이상 기입 금지 
>> 오류 발생.

자료를 잠깐 저장할 땐 useState()

사용법?
1. useState쓰고 탭 누르면
>> import { useState } from 'react'; 상단에 추가됨.
(아님 직접 입력하던가.)

2. useState(보관할 자료)

3. let [ a, b ] 선언하기.
a >> state에 보관했던 자료.
b >> state에 보관된 자료를 변경할 때 사용하는 함수.

Array 자료
let num = [ 1, 2, 3 ];

let a = num[0];  a는 1. 
let c = num[1];  c는 2.
>> 배열 순서에 따라 저장된 값을 대입.

Destructering 문법?

let [a, c] = [1, 2];  
>> 배열 순서에 따른 값이 아닌, 직접 값을 대입.

변수가 있는데 왜 굳이 state를 쓸까?
>> 변수와 state에 차이점이 존재한다.

그냥 변수를 사용하면 변수값이 변경됐을 때 자동 반영이 안 됨.
>> state를 사용하면 자동으로 html 재렌더링 됨.

3회차

/* eslint-disable */ 
>> 경고 메시지 제거 명령어.

** onClick  (event handler)
>> html요소를 클릭할 때 마다 {}안의 함수를 실행.
onClick의 {}안에는 함수만 넣을 수 있다.
<div onClick={함수}></div>

함수를 바로 {}안에 선언할 수도 있고, 위에 따로 선언해도 된다.
축약문 형태로 {}안에 선언하는 것 역시 가능하다.

함수 축약문? 
() => { 내용 }

** state 변경하는 법
useState 앞에 선언했던 변경함수를 {} 안에 넣어서 사용.

ex) state변경함수(새로운state);

** 4회차

array/object 다룰 때 원본은 수정하지 않고 사용하는 게 좋다.

let copy = [...a];
copy[0] = '수정할 내용';
변경함수(copy);


** state 변경 함수의 동작 원리.

기존 state랑 신규 state를 '=='로 비교함.
>> '기존 == 신규' 이면 변경 안 해줌.
>>> 컴퓨터 리소스 절약.

** array/object 특징.

let arr = [ 1, 2, 3 ];
>> JS에서는 배열을 선언하면 배열 이름 변수에 포인터가 할당된다.
>>> arr안에는 [ 1, 2, 3 ]이 저장된 주솟값만 가진다.
>>>> [ 1, 2, 3 ]은 램(RAM)에 저장된다.


** 배열의 값을 바꿨는데 html에 적용이 안되는 이유?
arr[0] = '4';
>> 배열의 값을 수정함
>>> 변수에 있던 포인터는 수정되지 않음.
>>>> 결국 두 화살표는 같다. 
>>>>> '기존 == 신규' 메커니즘에 의해 state가 수정되지 않는다. (컴퓨터가 바뀐 게 없다고 인식함.)


ex)

let arr = [ 1, 2, 3 ];
let copy = arr; << let arr에 있던 화살표가 복사됨.
copy[0] = 100; << 여기서 백날 값을 바꾸면 뭐함? 화살표(포인터 주솟값)는 그대로라 컴퓨터는 바뀐 게 없다고 인식하는데.
change(copy);

>> 변수1 & 변수2 화살표가 같으면 변수1 == 변수2 비교해도 'true' 값이 나옴.

이런 현상에 대해 더 알고 싶으면
>> reference data type에 대해 공부하기.

[...변수명]; << 이러면 화살표도 달라짐.

'...' 괄호를 벗긴다. 

결론 :

state가 array/object면 독립적 카피본(shallow copy or deep copy)을 만들어서 수정해야 한다.


** 5회차

HTML 특징 : 코드가 지저분함

컴포넌트를 만들어 사용하면? >> 코드를 직관적으로 명시 가능.
>> 내 코드를 처음 보는 사람도 편하고, 미래의 나도 편하고.

컴포넌트 만드는 법?

1. function을 만든다.
2. return() 안에 html을 담는다.
3. <함수명></함수명> 으로 작성한다. << 요고는 html 코드 작성하는 부분에 쓰기!


주의 사항

function은 항상 다른 function 외부에 작성해야 한다.
작명은 영어 대문자로 할 것.
return() 안에는 하나의 태그만 작성할 것! (병렬로 두개 금지)

병렬 기입을 하고 싶으면..

function 컴포넌트명() {
    return(
        <>
        <div></div>
        <div></div>
        </>
    )
}

>> 이렇게는 가능하다~

함수 표기법은 두 가지!

[1] <Modal></Modal>
[2] <Modal/>


컴포넌트를 만들어서 쓰면 좋은 경우.

1. 반복적인 html을 축약할 때.
2. 큰 페이지
3. 자주 변경 되는 것들.


컴포넌트의 단점?

state 가져다 쓸 때 문제 생김.
A 함수에 있던 변수를 B 함수에서 사용할 수 없기 때문에.


참고사항.
컴포넌트 만드는 두 번째 방법
let Modal = () => {} 
const Modal = () => {}

>> const로 작성하면 내가 실수로 값을 바꿨을 때 에러 표시해줌.

func or 대문자로 시작하면 >> component라고 알고 있어도 된다. 


** 6회차

동적인 UI

1. html, css로 미리 디자인 완성
2. UI의 현재 상태를 state로 저장
3. state에 따라 UI가 어떻게 보일지 작성 (조건문 활용.)


html 코드 쓰는 곳에 자바스크립트 쓰고 싶으면 {} 안에 작성.
다만, {} 사이에 조건문을 쓸 수 없음. (여긴 html코드 작성하는 곳 이니까.)
대신에 삼항 연산자 사용 가능.


{
    조건식 ? 참일때 실행 할 코드 : 거짓일 때 실행 할 코드
}

{
    modal == true ? <Modal/> : null
}

null > 텅 빈 값.
>> 비어있는 html 용으로 자주 사용한다.




** 7회차

map() 사용법


1. array 자료 갯수만큼 함수안의 코드 실행해줌.
2. 함수의 파라미터는 array안에 있던 자료.
3. return에 뭐 적으면 그걸 array안에 담아줌.

{
    여기 안에는 반복문 사용 불가.
}


{
    [1, 2, 3].map(function(){
        return <div>안녕</div>
    })
}

>> map()으로 같은 html 반복 생성하는 방법.

결론 : 비슷한 html 반복 생성하려면 map 쓰면 된다.

{
    state변수명.map(function(이름, i) {
        return(
            <div>
                <div>{ state변수명[i] }</div>
            </div>
        )
    }
}
