1회차.

document.querySelector('h4').innerHTML = post;
>> 기존 자바스크립트에서 html에 변수 넣던 방법.

변수 넣을 땐 {} 중괄호.  

style 넣을 땐 style = { { 스타일명 : '값' } }


2회차.

return() 안에는 병렬로 태그 2개 이상 기입 금지 
>> 오류 발생.

자료를 잠깐 저장할 땐 useState()

사용법?
1. useState쓰고 탭 누르면
>> import { useState } from 'react'; 상단에 추가됨.
(아님 직접 입력하던가.)

2. useState(보관할 자료)

3. let [ a, b ] 선언하기.
a >> state에 보관했던 자료.
b >> state에 보관된 자료를 변경할 때 사용하는 함수.

Array 자료
let num = [ 1, 2, 3 ];

let a = num[0];  a는 1. 
let c = num[1];  c는 2.
>> 배열 순서에 따라 저장된 값을 대입.

Destructering 문법?

let [a, c] = [1, 2];  
>> 배열 순서에 따른 값이 아닌, 직접 값을 대입.

변수가 있는데 왜 굳이 state를 쓸까?
>> 변수와 state에 차이점이 존재한다.

그냥 변수를 사용하면 변수값이 변경됐을 때 자동 반영이 안 됨.
>> state를 사용하면 자동으로 html 재렌더링 됨.

3회차

/* eslint-disable */ 
>> 경고 메시지 제거 명령어.

** onClick  (event handler)
>> html요소를 클릭할 때 마다 {}안의 함수를 실행.
onClick의 {}안에는 함수만 넣을 수 있다.
<div onClick={함수}></div>

함수를 바로 {}안에 선언할 수도 있고, 위에 따로 선언해도 된다.
축약문 형태로 {}안에 선언하는 것 역시 가능하다.

함수 축약문? 
() => { 내용 }

** state 변경하는 법
useState 앞에 선언했던 변경함수를 {} 안에 넣어서 사용.

ex) state변경함수(새로운state);

** 4회차

array/object 다룰 때 원본은 수정하지 않고 사용하는 게 좋다.

let copy = [...a];
copy[0] = '수정할 내용';
변경함수(copy);


** state 변경 함수의 동작 원리.

기존 state랑 신규 state를 '=='로 비교함.
>> '기존 == 신규' 이면 변경 안 해줌.
>>> 컴퓨터 리소스 절약.

** array/object 특징.

let arr = [ 1, 2, 3 ];
>> JS에서는 배열을 선언하면 배열 이름 변수에 포인터가 할당된다.
>>> arr안에는 [ 1, 2, 3 ]이 저장된 주솟값만 가진다.
>>>> [ 1, 2, 3 ]은 램(RAM)에 저장된다.


** 배열의 값을 바꿨는데 html에 적용이 안되는 이유?
arr[0] = '4';
>> 배열의 값을 수정함
>>> 변수에 있던 포인터는 수정되지 않음.
>>>> 결국 두 화살표는 같다. 
>>>>> '기존 == 신규' 메커니즘에 의해 state가 수정되지 않는다. (컴퓨터가 바뀐 게 없다고 인식함.)


ex)

let arr = [ 1, 2, 3 ];
let copy = arr; << let arr에 있던 화살표가 복사됨.
copy[0] = 100; << 여기서 백날 값을 바꾸면 뭐함? 화살표(포인터 주솟값)는 그대로라 컴퓨터는 바뀐 게 없다고 인식하는데.
change(copy);

>> 변수1 & 변수2 화살표가 같으면 변수1 == 변수2 비교해도 'true' 값이 나옴.

이런 현상에 대해 더 알고 싶으면
>> reference data type에 대해 공부하기.

[...변수명]; << 이러면 화살표도 달라짐.

'...' 괄호를 벗긴다. 

결론 :

state가 array/object면 독립적 카피본(shallow copy or deep copy)을 만들어서 수정해야 한다.



